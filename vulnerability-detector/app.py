from flask import Flask, request, render_template, jsonify
import os
import requests
import math
from uuid import uuid4
from main import predict
import datetime
app = Flask(__name__)

BLOCKCHAIN_BASE_URL = "http://127.0.0.1:3000"
# upload to flaskupload in current path
UPLOAD_DIR = os.path.join(os.path.dirname(
    os.path.abspath(__file__)), 'flask_uploads')


def create_dir(dir_name):
    if not os.path.exists(dir_name):
        os.makedirs(dir_name)


# def send_file_to_blockchain(file_path, payload):
#     # Send file to blockchain
#     url = BLOCKCHAIN_BASE_URL + '/upload'
#     with open(file_path, 'rb') as file:
#         files = {'file': file}
#         response = requests.post(url, files=files, data=payload)


# @app.route('/')
# def index():
#     return render_template("index.html")

# predict
@app.route('/predict', methods=['POST'])
def postdata():

    print("Received request", request.files)
    f = request.files['file']
    dev_id = request.form.get("dev_id")
    print(dev_id)

    filename = f.filename
    print(filename)
    # assign a random name to the file
    random_name = str(uuid4()) + '_' + filename
    file_path = os.path.join(UPLOAD_DIR, random_name)
    f.save(file_path)

    # predict vulnerability
    result = predict(inference_path=file_path)
    print("File uploaded to flask server")

    # if result["is_vulnerable"]:
    # try:
    #     send_file_to_blockchain(file_path, result)
    # except:
    #     print("Error sending file to blockchain")

    # return json.dumps(result)
    vulnerable_score = round(result["score"]*100, 3)
    nonvulnerable_score = round(100-(result["score"] * 100), 3)
    return jsonify({
        "is_vulnerable": result["is_vulnerable"],
        "vulnerable_score": vulnerable_score,
        "nonvulnerable_score": nonvulnerable_score,
        "developer_id": dev_id,
        "filename": filename,
        "ptimestamp": math.floor(datetime.datetime.now().timestamp())})


if __name__ == "__main__":
    create_dir(UPLOAD_DIR)
    app.run(port=5000, debug=True)
