# -*- coding: utf-8 -*-
"""
Created on Mon Jul 22 12:16:36 2019

@author: Daniel Lin

"""

import os
os.environ['TF_CPP_MIN_LOG_LEVEL'] = '3'
from tensorflow.keras.preprocessing.sequence import pad_sequences
from keras.models import load_model

from src.DataLoader import LoadPickleData, LoadCFile
from src.models.attention.HAN import AttentionLayer

class Helper():
    ''' Super class Solver for all kinds of tasks'''
    def __init__(self, config, paras):
        self.config = config
        self.paras = paras
        self.tokenizer_saved_path = self.config['embedding_settings']['embedding_model_saved_path']
        # if not os.path.exists(self.paras.data_dir): os.makedirs(self.paras.data_dir)
        # if not os.path.exists(self.config['inference_settings']['model_save_path']): os.makedirs(self.config['inference_settings']['model_save_path']) 
        if not os.path.exists(self.tokenizer_saved_path): os.makedirs(self.tokenizer_saved_path)
        ELMo_padding = 1000
        setattr(self, 'ELMo_padding', ELMo_padding)
            
    def LoadToknizer(self, path_of_tokenizer):
        tokenizer = LoadPickleData(path_of_tokenizer)
        return tokenizer
    
    def verbose(self, msg):
        ''' Verbose function for print information to stdout'''
        if self.paras.verbose == 1:
            print('[INFO]', msg)
    
    def padding(self, sequences_to_pad):
        padded_seq = pad_sequences(sequences_to_pad, maxlen = self.config['model_settings']['model_para']['max_sequence_length'], padding ='post')
        return padded_seq
    
    def loadData(self, data_path):
        ''' Load data for training/validation'''
        self.verbose('Loading data from '+ os.getcwd() + os.sep + data_path + '....')
        c_source = LoadCFile(data_path)
        total_list = [c_source]
        return total_list
    
    def modelLoader(self):
        trained_model_path = self.paras.trained_model
        if os.path.isfile(trained_model_path):
            # Load the model and print the model details.
            if (str(self.config['model_settings']['model']).lower() == 'han'):
                trained_model = load_model(trained_model_path, custom_objects = {'AttentionLayer': AttentionLayer})
            else:
                trained_model = load_model(trained_model_path)
            trained_model.summary()
            return trained_model
        else:
            self.verbose("Failed to load the trained model!")


# Inference
class Inference(Helper):
    ''' Handler for complete inference progress'''
    def __init__(self,config,paras):
        super(Inference, self).__init__(config,paras)
        # if not os.path.exists(self.paras.output_dir): os.makedirs(self.paras.output_dir)
        self.verbose('Start testing process....')

    # New Inference function
    def loadInferenceSet(self):
        self.verbose ("Loading test data from " + os.getcwd() + os.sep + self.config['inference_settings']['inference_path'])
        inference_data = self.loadData(self.config['inference_settings']['inference_path'])  
        self.verbose("Pad the sequence to unified length...")
        embedding_method = str(self.paras.embedding).lower()
        if embedding_method == 'elmo':
          test_list_pad = [' '.join(t.split()[0:self.ELMo_padding]) for t in inference_data]
        else:
          tokenizer = self.LoadToknizer(self.tokenizer_saved_path + 'tokenizer.pickle')
          test_sequence = tokenizer.texts_to_sequences(inference_data)
          test_list_pad = self.padding(test_sequence)
          inference_set_x = test_list_pad
            
        return inference_set_x

    def checkIfFileIsVulnerable(self, probs):
        # print(probs, "PROBS")
        if probs[0][0] >= 0.5:
          return True
        else:
          return False
    
    def predict_vulnerability(self):
        print('Inference started')
        inference_set_x = self.loadInferenceSet()
        model = self.modelLoader()
        probs = model.predict(inference_set_x, batch_size = self.config['inference_settings']['network_config']['batch_size'], verbose = self.paras.verbose)
        is_vulnerable = self.checkIfFileIsVulnerable(probs)
        result = {
            "score": round(float(probs[0][0]),3),
            "is_vulnerable": is_vulnerable,
        }
        return result
    